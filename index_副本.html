<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EHS Digital Human Assistant</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        /* =========================================
           1. Global & Reset
           ========================================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', 'PingFang SC', sans-serif;
            background: url('jkdp.png') no-repeat center center fixed;
            background-size: cover;
            /* Fallback in case image loads slowly */
            background-color: #000;
        }

        /* =========================================
           2. Avatar Container
           ========================================= */
        #avatar-container {
            position: fixed;
            /* Default Position: Bottom Right */
            right: 5%;
            bottom: 120px; /* Lifted up to make room for input bar below */
            width: 35vh; /* Responsive width based on height */
            height: 70vh;
            z-index: 1000;
            will-change: transform;
            /* Initial transition for entrance/minimize effects */
            /* Note: 'transform' transition is removed via JS during drag */
            transition: transform 0.1s linear, opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1), scale 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
        }

        /* Inner wrapper for Breathing Animation */
        /* Separating position (container) from local animation (wrapper) avoids conflict */
        .avatar-breathing-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-12px); }
        }

        /* Avatar Image */
        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: bottom center;
            display: block;
            pointer-events: none; /* Pass clicks to container */
            /* Soft fade at the bottom to blend with glow */
            -webkit-mask-image: linear-gradient(to top, transparent 0%, black 15%, black 100%);
            mask-image: linear-gradient(to top, transparent 0%, black 15%, black 100%);
            /* Slight drop shadow for depth */
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.2));
        }

        /* Holographic Base (Glow) */
        .holographic-base {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 120%;
            height: 40px;
            background: radial-gradient(ellipse at center, rgba(0, 255, 255, 0.6) 0%, rgba(0, 255, 255, 0) 70%);
            mix-blend-mode: screen;
            pointer-events: none;
            /* Sync with breathing */
            animation: base-pulse 3s ease-in-out infinite;
        }

        @keyframes base-pulse {
            0%, 100% { opacity: 0.4; transform: translateX(-50%) scale(0.9); }
            50% { opacity: 0.8; transform: translateX(-50%) scale(1.1); }
        }

        /* =========================================
           3. HUD Bubble
           ========================================= */
        .hud-bubble {
            position: absolute;
            top: 5%;
            right: 85%; /* Moved slightly left */
            width: 320px; /* Increased width for charts */
            max-height: 350px;
            overflow-y: auto;
            padding: 12px;
            background: rgba(0, 20, 30, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            /* Glassmorphism */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1), inset 0 0 10px rgba(0, 255, 255, 0.05);
            
            color: #fff;
            font-size: 14px;
            line-height: 1.5;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            
            /* Enable selection and pointer events */
            user-select: text; 
            cursor: auto;
        }

        /* Prevent drag on bubble interaction */
        .hud-bubble * {
            user-select: text;
        }

        /* Scrollbar Styling */
        .hud-bubble::-webkit-scrollbar {
            width: 4px;
        }
        .hud-bubble::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
        }
        .hud-bubble::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.3);
            border-radius: 2px;
        }
        
        .msg-item {
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease;
        }
        
        .msg-user {
            align-self: flex-end;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.1);
            color: #ccffff;
        }
        
        .msg-system {
            align-self: flex-start;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
        }

        .chart-container {
            width: 100%;
            height: 200px;
            margin-top: 8px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Decoration line removed or adjusted since bubble grows */
        .hud-bubble::after {
            display: none; 
        }

        /* =========================================
           4. Input Bar
           ========================================= */
        .input-container {
            position: absolute;
            bottom: -70px; /* Below the base */
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            height: 50px;
            z-index: 1001;
            perspective: 1000px;
        }

        .input-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Common style for modes */
        .mode-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 25px;
            background: rgba(0, 10, 20, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s ease, transform 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            cursor: pointer;
        }

        .mode-panel.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        /* Voice Mode Animation */
        .voice-wave {
            display: flex;
            align-items: center;
            gap: 4px;
            height: 24px;
        }
        .wave-bar {
            width: 4px;
            background: #0ff;
            border-radius: 2px;
            animation: wave-anim 1s infinite ease-in-out;
            box-shadow: 0 0 8px #0ff;
        }
        .wave-bar:nth-child(1) { height: 10px; animation-delay: 0.0s; }
        .wave-bar:nth-child(2) { height: 18px; animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { height: 24px; animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { height: 18px; animation-delay: 0.1s; }
        .wave-bar:nth-child(5) { height: 10px; animation-delay: 0.0s; }

        @keyframes wave-anim {
            0%, 100% { height: 8px; opacity: 0.5; }
            50% { height: 24px; opacity: 1; }
        }

        /* Keyboard Mode */
        .keyboard-input {
            width: 85%;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            color: #fff;
            font-size: 14px;
            text-align: left;
        }
        .keyboard-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        .input-icon {
            color: #0ff;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transition: background 0.2s ease, transform 0.2s ease;
            cursor: pointer;
        }
        
        .input-icon:hover {
            background: rgba(0, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .send-btn, .stop-btn {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0ff;
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }
        .send-btn:active, .stop-btn:active {
            transform: scale(0.9);
        }
        .send-btn:hover, .stop-btn:hover {
            color: #fff;
        }
        
        .stop-btn {
            color: #ff4d4d;
        }
        .stop-btn:hover {
            color: #ff9999;
        }

        .send-btn.hidden, .stop-btn.hidden {
            display: none;
        }

        /* =========================================
           5. Controls (Minimize)
           ========================================= */
        .minimize-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.4);
            color: #0ff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1002;
            transition: all 0.2s ease;
            opacity: 0; /* Hidden by default, show on hover/interaction or always? Let's show always for usability */
            opacity: 0.8;
        }
        .minimize-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: scale(1.1);
            opacity: 1;
        }
        /* SVG Icon for minimize */
        .icon-minus {
            width: 14px;
            height: 2px;
            background: currentColor;
        }

        /* =========================================
           6. Floating Action Button (FAB)
           ========================================= */
        .fab-trigger {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #0ff, #008888);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), 0 0 40px rgba(0, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
            cursor: pointer;
            
            /* Initial State: Hidden */
            opacity: 0;
            transform: scale(0);
            pointer-events: none;
            
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .fab-trigger.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        
        /* Pulse ring */
        .fab-trigger::before {
            content: '';
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.5);
            animation: ring-pulse 2s infinite;
        }
        
        @keyframes ring-pulse {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .fab-icon {
            width: 24px;
            height: 24px;
            fill: #fff;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));
        }

        /* Minimized State applied to container */
        #avatar-container.minimized {
            opacity: 0;
            transform: scale(0) translate3d(0,0,0) !important; 
            /* Note: We need to override the inline translate3d style set by JS. 
               However, inline styles have high specificity. 
               A cleaner way in JS is to clear the transform or handle the class logic carefully.
               Here !important forces the scale down, but the position might be weird if translate is also there.
               Actually, scale(0) makes position irrelevant visually, but let's handle it in JS for cleanliness.
            */
            pointer-events: none;
        }

    </style>
</head>
<body>

    <!-- Floating Action Button (Resume) -->
    <div id="fab-trigger" class="fab-trigger active">
        <svg class="fab-icon" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"/>
        </svg>
    </div>

    <!-- Main Avatar Container -->
    <div id="avatar-container" class="minimized">
        <!-- Minimize Button -->
        <div id="minimize-btn" class="minimize-btn" title="收起">
            <div class="icon-minus"></div>
        </div>

        <!-- Breathing Wrapper -->
        <div class="avatar-breathing-wrapper">
            
            <!-- HUD Bubble -->
            <div class="hud-bubble" id="chat-history">
                <div class="msg-item msg-system">
                    <strong>EHS 智能助手</strong><br>
                    <span>全息系统正常，等待指令...</span>
                </div>
            </div>

            <!-- Avatar -->
            <img src="jimeng.png" alt="Digital Human" class="avatar-img" draggable="false">

            <!-- Holographic Base -->
            <div class="holographic-base"></div>

            <!-- Input Bar -->
            <div id="input-container" class="input-container">
                <div class="input-wrapper">
                    <!-- Voice Mode (Default) -->
                    <div id="mode-voice" class="mode-panel">
                        <div class="voice-wave">
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                            <div class="wave-bar"></div>
                        </div>
                        <span style="margin-left: 10px; color: #0ff; font-size: 13px;">点击切换键盘</span>
                    </div>

                    <!-- Keyboard Mode -->
                    <div id="mode-keyboard" class="mode-panel hidden">
                        <div class="input-icon mode-switch-btn" title="切换语音输入">
                            <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor">
                                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.66 9 5v6c0 1.66 1.34 3 3 3z"/>
                                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                            </svg>
                        </div>
                        <input type="text" class="keyboard-input" placeholder="输入您的问题...">
                        
                        <!-- Send Button -->
                        <div class="send-btn" title="发送">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path>
                            </svg>
                        </div>

                        <!-- Stop Button (Hidden by default) -->
                        <div class="stop-btn hidden" title="停止生成">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                <rect x="6" y="6" width="12" height="12" rx="2" ry="2" />
                            </svg>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('avatar-container');
            const minimizeBtn = document.getElementById('minimize-btn');
            const fabTrigger = document.getElementById('fab-trigger');
            const inputContainer = document.getElementById('input-container');
            const modeVoice = document.getElementById('mode-voice');
            const modeKeyboard = document.getElementById('mode-keyboard');
            const keyboardInput = modeKeyboard.querySelector('input');
            const sendBtn = modeKeyboard.querySelector('.send-btn');
            const stopBtn = modeKeyboard.querySelector('.stop-btn');
            const chatHistory = document.getElementById('chat-history');

            // State
            let isDragging = false;
            let isGenerating = false;
            let currentTimeout = null;
            let chartTimeout = null;
            
            // State for Drag (restoring removed variables)
            let startX = 0, startY = 0;
            let initialTranslateX = 0, initialTranslateY = 0;
            let currentTranslateX = 0, currentTranslateY = 0;
            
            // Boundary constraints (deltas relative to initial position)
            let minX = 0, maxX = 0, minY = 0, maxY = 0;

            // =========================================
            // Drag Interaction
            // =========================================
            container.addEventListener('mousedown', dragStart);
            container.addEventListener('touchstart', dragStart, { passive: false });
            
            // Stop drag propagation from Bubble and Input
            chatHistory.addEventListener('mousedown', (e) => e.stopPropagation());
            chatHistory.addEventListener('touchstart', (e) => e.stopPropagation());
            inputContainer.addEventListener('mousedown', (e) => e.stopPropagation());
            inputContainer.addEventListener('touchstart', (e) => e.stopPropagation());

            function dragStart(e) {
                // Ignore clicks on buttons/inputs (handled by propagation stop, but just in case)
                if (e.target.closest('.minimize-btn')) {
                    return;
                }

                // Get Event Position
                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

                isDragging = true;
                startX = clientX;
                startY = clientY;

                // 1. Critical: Remove transition for instant follow
                container.style.transition = 'none';

                // 2. Calculate Boundaries
                // We want to prevent the element from leaving the viewport.
                // The element is positioned with bottom/right.
                // rect gives current visual position.
                const rect = container.getBoundingClientRect();
                const viewportW = window.innerWidth;
                const viewportH = window.innerHeight;

                // Calculate allowed movement from CURRENT position
                // Move Left: max allowed is -rect.left
                // Move Right: max allowed is viewportW - rect.right
                // Move Up: max allowed is -rect.top
                // Move Down: max allowed is viewportH - rect.bottom
                
                minX = -rect.left;
                maxX = viewportW - rect.right;
                minY = -rect.top;
                maxY = viewportH - rect.bottom;

                // We are tracking cumulative translation in currentTranslateX/Y.
                // The boundaries above are for the DELTA of this specific drag.
                // Actually, easier logic:
                // NewTranslate = OldTranslate + Delta
                // But we must clamp (OldTranslate + Delta) such that the resulting rect is within bounds.
                // 
                // Let's stick to: calculate delta, clamp delta, add to initial.
            }

            window.addEventListener('mousemove', dragMove);
            window.addEventListener('touchmove', dragMove, { passive: false });

            function dragMove(e) {
                if (!isDragging) return;
                
                // Prevent scrolling on touch
                if(e.type === 'touchmove') e.preventDefault();

                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;

                // Apply clamping based on the boundaries calculated at start
                // Since minX/maxX are relative to the start position of THIS drag
                const clampedDx = Math.max(minX, Math.min(maxX, dx));
                const clampedDy = Math.max(minY, Math.min(maxY, dy));

                // Update Position
                // We add the clamped delta to the translation value we had before this drag started
                const newX = initialTranslateX + clampedDx;
                const newY = initialTranslateY + clampedDy;
                
                // Use translate3d for hardware acceleration
                container.style.transform = `translate3d(${newX}px, ${newY}px, 0)`;
                
                // Update current state purely for tracking (though we won't use it until mouseup)
                currentTranslateX = newX;
                currentTranslateY = newY;
            }

            window.addEventListener('mouseup', dragEnd);
            window.addEventListener('touchend', dragEnd);

            function dragEnd() {
                if (!isDragging) return;
                isDragging = false;

                // Commit the new position
                initialTranslateX = currentTranslateX;
                initialTranslateY = currentTranslateY;

                // Restore transition for other animations (like minimize)
                // Note: We don't want a transition on transform immediately if we are just staying put,
                // but it's fine.
                container.style.transition = 'transform 0.1s linear, opacity 0.5s ease, scale 0.5s ease';
            }


            // =========================================
            // Minimize / Expand Logic
            // =========================================
            minimizeBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent drag start
                
                // Shrink and Fade Out
                // We add a class, but we must ensure the transform scale(0) takes precedence
                // while preserving the translate position? 
                // Actually, if we scale(0), the position doesn't matter visually.
                // CSS !important on scale will handle it.
                container.classList.add('minimized');
                
                // Show FAB
                fabTrigger.classList.add('active');
            });

            fabTrigger.addEventListener('click', () => {
                // Restore
                container.classList.remove('minimized');
                fabTrigger.classList.remove('active');
                
                // Ensure the transform is restored to the drag position
                // The class removal restores the CSS rules, but the inline style remains.
                // The inline style is translate3d(...).
                // The CSS transition will handle the scale back to 1.
            });


            // =========================================
            // Input Mode Switch & Send Logic
            // =========================================
            // Click to toggle
            inputContainer.addEventListener('click', (e) => {
                // If clicking send button or input, don't toggle mode
                if (e.target.closest('.send-btn') || e.target.closest('input')) return;

                if (modeKeyboard.classList.contains('hidden')) {
                    // Switch to Keyboard
                    modeVoice.classList.add('hidden');
                    modeKeyboard.classList.remove('hidden');
                    setTimeout(() => keyboardInput.focus(), 100);
                } else {
                    // Switch to Voice
                    modeKeyboard.classList.add('hidden');
                    modeVoice.classList.remove('hidden');
                }
            });
            
            // Prevent drag when clicking input
            keyboardInput.addEventListener('mousedown', (e) => e.stopPropagation());
            keyboardInput.addEventListener('touchstart', (e) => e.stopPropagation());

            // Send Logic
            function sendMessage() {
                const text = keyboardInput.value.trim();
                if (!text) return;
                
                // Set generating state
                isGenerating = true;
                sendBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');

                // 1. Add User Message
                appendMessage(text, 'user');
                
                // Clear input
                keyboardInput.value = '';
                
                // 2. Simulate Response
                // Show "Thinking..." or just wait a bit
                currentTimeout = setTimeout(() => {
                    const systemMsgDiv = appendMessage('正在分析数据...', 'system');
                    
                    // Update the message content with a chart after a delay
                    chartTimeout = setTimeout(() => {
                        systemMsgDiv.innerHTML = `<strong>分析结果：</strong><br>关于 "${text}" 的数据如下：`;
                        
                        // Create chart container
                        const chartDiv = document.createElement('div');
                        chartDiv.className = 'chart-container';
                        systemMsgDiv.appendChild(chartDiv);
                        
                        // Render Chart
                        renderChart(chartDiv);
                        
                        // Scroll to bottom
                        chatHistory.scrollTop = chatHistory.scrollHeight;
                        
                        // Reset State
                        isGenerating = false;
                        sendBtn.classList.remove('hidden');
                        stopBtn.classList.add('hidden');
                        
                    }, 800);
                }, 400);
            }
            
            // Stop Logic
            stopBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isGenerating) return;
                
                // Clear timeouts
                if (currentTimeout) clearTimeout(currentTimeout);
                if (chartTimeout) clearTimeout(chartTimeout);
                
                // Append "Stopped" message if needed or just stop
                appendMessage('已停止生成。', 'system');
                
                // Reset State
                isGenerating = false;
                sendBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
            });

            function appendMessage(content, type) {
                const div = document.createElement('div');
                div.className = `msg-item msg-${type}`;
                div.innerHTML = content; // Allow HTML
                chatHistory.appendChild(div);
                chatHistory.scrollTop = chatHistory.scrollHeight;
                return div;
            }

            function renderChart(container) {
                // Initialize ECharts
                const myChart = echarts.init(container);
                
                // Dummy Data
                const option = {
                    backgroundColor: 'transparent',
                    tooltip: {
                        trigger: 'item'
                    },
                    grid: {
                        top: '10%',
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'category',
                        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
                        axisLine: { lineStyle: { color: '#0ff' } },
                        axisLabel: { color: '#fff' }
                    },
                    yAxis: {
                        type: 'value',
                        splitLine: { lineStyle: { color: 'rgba(0,255,255,0.1)' } },
                        axisLabel: { color: '#fff' }
                    },
                    series: [
                        {
                            data: [120, 200, 150, 80, 70],
                            type: 'bar',
                            itemStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#00f2fe' },
                                    { offset: 1, color: '#4facfe' }
                                ])
                            },
                            showBackground: true,
                            backgroundStyle: {
                                color: 'rgba(180, 180, 180, 0.2)'
                            }
                        }
                    ]
                };
                
                myChart.setOption(option);
                
                // Resize handler (optional, but good for robustness)
                window.addEventListener('resize', () => myChart.resize());
            }

            sendBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                sendMessage();
            });

            keyboardInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

        });
    </script>
</body>
</html>
